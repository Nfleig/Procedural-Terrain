// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel HeightMap
#pragma kernel JitterPoints
#pragma kernel SetMapSettings

#pragma exclude_renderers d3d11_9x
#pragma exclude_renderers d3d9
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise2D.hlsl"

RWTexture2D<float4> Result;

struct ChunkMap
{
	RWTexture2D<float4> MapTexture;
	float2 ChunkPosition;
};

struct Biome
{
	float temperature;
	float moisture;
};

struct Octave
{
	float frequency;
	float2 offset;
	float amplitude;
};

struct GPUMapSettings
{
	float Scale;
	float Size;
	float2 Offset;
	int OctaveCount;
};

struct Output
{
	int chunkBiome;
	float averageElevation;
};

RWStructuredBuffer<float3> jitteredPoints;
RWStructuredBuffer<Output> OutputBuffer;
int jitteredPointsLength;
StructuredBuffer<Biome> Biomes;
StructuredBuffer<GPUMapSettings> maps;
int BiomeLength;
bool DrawBiomes;
bool BiomeBlending;
bool BiomeHeights;

float BiomeBlendRadius;

RWTexture2D<float4> HeightMapTexture;
RWTexture2D<float4> ColorMapTexture;
Texture2D<float4> HeightCurveTexture;
Texture2D<float4> BiomeGradientTexture;
Texture2D<float4> BiomeCurveTexture;


StructuredBuffer<Octave> HeightMapOctaves;
StructuredBuffer<Octave> TemperatureMapOctaves;
StructuredBuffer<Octave> MoistureMapOctaves;
StructuredBuffer<Octave> BiomeBlendMapOctaves;
StructuredBuffer<Octave> JitterMapOctaves;

float Resolution;
float CurveResolution;

int MapID;
float2 Offset;
float Scale;
float Size;
float2 ChunkPosition;
StructuredBuffer<Octave> Octaves;
int OctaveCount;

float CalculateTemperatureNoise(float2 position)
{
	float mapSize = maps[0].Size / Resolution;
	float2 chunkPosition = ChunkPosition;
	while (position.x < 0)
	{
		chunkPosition.x -= 1;
		position.x += mapSize;
	}
	while (position.x > mapSize)
	{
		chunkPosition.x += 1;
		position.x -= mapSize;
	}
	while (position.y < 0)
	{
		chunkPosition.y -= 1;
		position.y += mapSize;
	}
	while (position.y > mapSize)
	{
		chunkPosition.y += 1;
		position.y -= mapSize;
	}
	float2 offset = maps[1].Offset + chunkPosition - float2(2 * chunkPosition.x / Resolution, 2 * chunkPosition.y / Resolution);
	float height;
	float noiseHeight = 0;
	float sumAmplitudes = 0;
	for (int i = 0; i < maps[1].OctaveCount; i++)
	{
		float noiseX = (position.x + offset.x) / maps[1].Scale;
		float noiseY = (position.y + offset.y) / maps[1].Scale;
		noiseHeight += TemperatureMapOctaves[i].amplitude * ClassicNoise(float2(noiseX * TemperatureMapOctaves[i].frequency + TemperatureMapOctaves[i].offset.x, noiseY * TemperatureMapOctaves[i].frequency + TemperatureMapOctaves[i].offset.y)) / 2 + 0.0875f;
		sumAmplitudes += TemperatureMapOctaves[i].amplitude;
	}
	height = noiseHeight / sumAmplitudes;
	int curveIndex = (int) (height * CurveResolution);
	height = HeightCurveTexture[int2(curveIndex, 1)];
	return height;
}

float CalculateJitterNoise(float2 position)
{
	float mapSize = maps[0].Size / Resolution;
	float2 chunkPosition = ChunkPosition;
	while (position.x < 0)
	{
		chunkPosition.x -= 1;
		position.x += mapSize;
	}
	while (position.x > mapSize)
	{
		chunkPosition.x += 1;
		position.x -= mapSize;
	}
	while (position.y < 0)
	{
		chunkPosition.y -= 1;
		position.y += mapSize;
	}
	while (position.y > mapSize)
	{
		chunkPosition.y += 1;
		position.y -= mapSize;
	}
	float2 offset = chunkPosition - float2(2 * chunkPosition.x / Resolution, 2 * chunkPosition.y / Resolution);
	float height;
	float noiseHeight = 0;
	float sumAmplitudes = 0;
	for (int i = 0; i < 4; i++)
	{
		float noiseX = (position.x + offset.x) / 0.001;
		float noiseY = (position.y + offset.y) / 0.001;
		noiseHeight += JitterMapOctaves[i].amplitude * ClassicNoise(float2(noiseX * JitterMapOctaves[i].frequency + JitterMapOctaves[i].offset.x, noiseY * JitterMapOctaves[i].frequency + JitterMapOctaves[i].offset.y)) / 2 + 0.0875f;
		sumAmplitudes += JitterMapOctaves[i].amplitude;
	}
	height = noiseHeight / sumAmplitudes;
	int curveIndex = (int) (height * CurveResolution);
	height = HeightCurveTexture[int2(curveIndex, 4)];
	return height;
}

float CalculateBiomeBlendNoise(float2 position)
{
	float mapSize = maps[0].Size / Resolution;
	float2 chunkPosition = ChunkPosition;
	while (position.x < 0)
	{
		chunkPosition.x -= 1;
		position.x += mapSize;
	}
	while (position.x > mapSize)
	{
		chunkPosition.x += 1;
		position.x -= mapSize;
	}
	while (position.y < 0)
	{
		chunkPosition.y -= 1;
		position.y += mapSize;
	}
	while (position.y > mapSize)
	{
		chunkPosition.y += 1;
		position.y -= mapSize;
	}
	float2 offset = maps[3].Offset + chunkPosition - float2(2 * chunkPosition.x / Resolution, 2 * chunkPosition.y / Resolution);
	float height;
	float noiseHeight = 0;
	float sumAmplitudes = 0;
	for (int i = 0; i < maps[3].OctaveCount; i++)
	{
		float noiseX = (position.x + offset.x) / maps[3].Scale;
		float noiseY = (position.y + offset.y) / maps[3].Scale;
		noiseHeight += BiomeBlendMapOctaves[i].amplitude * ClassicNoise(float2(noiseX * BiomeBlendMapOctaves[i].frequency + BiomeBlendMapOctaves[i].offset.x, noiseY * BiomeBlendMapOctaves[i].frequency + BiomeBlendMapOctaves[i].offset.y)) / 2 + 0.0875f;
		sumAmplitudes += BiomeBlendMapOctaves[i].amplitude;
	}
	height = noiseHeight / sumAmplitudes;
	int curveIndex = (int) (height * CurveResolution);
	height = HeightCurveTexture[int2(curveIndex, 3)];
	return height;
}

float CalculateMoistureNoise(float2 position)
{
	float mapSize = maps[0].Size / Resolution;
	float2 chunkPosition = ChunkPosition;
	while (position.x < 0)
	{
		chunkPosition.x -= 1;
		position.x += mapSize;
	}
	while (position.x > mapSize)
	{
		chunkPosition.x += 1;
		position.x -= mapSize;
	}
	while (position.y < 0)
	{
		chunkPosition.y -= 1;
		position.y += mapSize;
	}
	while (position.y > mapSize)
	{
		chunkPosition.y += 1;
		position.y -= mapSize;
	}
	float2 offset = maps[0].Offset + chunkPosition - float2(2 * chunkPosition.x / Resolution, 2 * chunkPosition.y / Resolution);
	float height;
	float noiseHeight = 0;
	float sumAmplitudes = 0;
	for (int i = 0; i < maps[2].OctaveCount; i++)
	{
		float noiseX = (position.x + offset.x) / maps[2].Scale;
		float noiseY = (position.y + offset.y) / maps[2].Scale;
		noiseHeight += MoistureMapOctaves[i].amplitude * ClassicNoise(float2(noiseX * MoistureMapOctaves[i].frequency + MoistureMapOctaves[i].offset.x, noiseY * TemperatureMapOctaves[i].frequency + MoistureMapOctaves[i].offset.y)) / 2 + 0.0875f;
		sumAmplitudes += MoistureMapOctaves[i].amplitude;
	}
	height = noiseHeight / sumAmplitudes;
	int curveIndex = (int) (height * CurveResolution);
	height = HeightCurveTexture[int2(curveIndex, 2)];
	return height;
}

int GetBiome(float2 position)
{
	float temperature = CalculateTemperatureNoise(float2(position.x, position.y));
	float moisture = CalculateMoistureNoise(float2(position.x, position.y));
	//float moisture = 0;
	for (int i = 0; i < BiomeLength; i++)
	{
		if (temperature <= Biomes[i].temperature)
		{
			if (moisture <= Biomes[i].moisture)
			{
				return i;
			}
		}
	}
	return 0;
}
float CalculateNoise(float2 position)
{
	float mapSize = maps[0].Size / Resolution;
	float2 chunkPosition = ChunkPosition;
	while (position.x < 0)
	{
		chunkPosition.x -= 1;
		position.x += mapSize;
	}
	while (position.x > mapSize)
	{
		chunkPosition.x += 1;
		position.x -= mapSize;
	}
	while (position.y < 0)
	{
		chunkPosition.y -= 1;
		position.y += mapSize;
	}
	while (position.y > mapSize)
	{
		chunkPosition.y += 1;
		position.y -= mapSize;
	}
	float2 offset = maps[0].Offset + chunkPosition - float2(2 * chunkPosition.x / Resolution, 2 * chunkPosition.y / Resolution);
	float height;
	float noiseHeight = 0;
	float sumAmplitudes = 0;
	for (int i = 0; i < maps[0].OctaveCount; i++)
	{
		float noiseX = (position.x + offset.x) / maps[0].Scale;
		float noiseY = (position.y + offset.y) / maps[0].Scale;
		noiseHeight += HeightMapOctaves[i].amplitude * ClassicNoise(float2(noiseX * HeightMapOctaves[i].frequency + HeightMapOctaves[i].offset.x, noiseY * HeightMapOctaves[i].frequency + HeightMapOctaves[i].offset.y)) / 2 + 0.0875f;
		sumAmplitudes += HeightMapOctaves[i].amplitude;
	}
	height = noiseHeight / sumAmplitudes;
	return height;
}

[numthreads(1, 1, 1)]
void SetMapSettings(uint3 id : SV_DispatchThreadID) 
{
	if (MapID == 0) //Height Map
	{
		HeightMapOctaves = Octaves;
	} else if (MapID == 1) //Temperature Map
	{
		TemperatureMapOctaves = Octaves;
	} else if (MapID == 2) //Moisture Map
	{
		MoistureMapOctaves = Octaves;
	}else if (MapID == 3) //Jitter Map
	{
		
	}

}

[numthreads(10, 1, 1)]
void JitterPoints(uint3 id : SV_DispatchThreadID)
{
	float3 oldPoint = jitteredPoints[id.x];
	if (oldPoint.z % 1 != 0)
	{
		float x = oldPoint.x / Resolution;
		float y = oldPoint.y / Resolution;
		float dir = CalculateJitterNoise(float2(x, y)) * 2 * 3.14159;
	
		float dist = 1 / Resolution;
		float3 newPoint = float3(x + (cos(dir) * dist), y + (sin(dir) * dist), 0.0);
		newPoint.z = (float) GetBiome(float2(newPoint.x, newPoint.y));
	
		if (OutputBuffer[0].chunkBiome == -2)
			OutputBuffer[0].chunkBiome = GetBiome(float2(0, 0));
		if (newPoint.z != OutputBuffer[0].chunkBiome)
			OutputBuffer[0].chunkBiome = -1;
	
		jitteredPoints[id.x] = newPoint;
	}
}

float4 BlendBiomes(float2 position, int curveIndex)
{
	float4 color = float4(0, 0, 0, 0);
	bool firstBlend = false;
	float noise = CalculateBiomeBlendNoise(position);
	float radius = sqrt(2) / 2;
	float maximumRadius = radius * sqrt(2) + (1 / Resolution);
	float sumWeights = 0;
	int points = 0;
	for (int i = 0; i < jitteredPointsLength; i++)
	{
		float Distance = distance(position, float2(jitteredPoints[i].x, jitteredPoints[i].y));
		float centerWeight = distance(float2(Size / 2 / Resolution, Size / 2 / Resolution), float2(jitteredPoints[i].x, jitteredPoints[i].y)) / maximumRadius;
		if (Distance <= BiomeBlendRadius)
		{
			float distanceWeight = (1 - (Distance / BiomeBlendRadius)) * noise + 0.05;
			sumWeights += distanceWeight;
			points++;
			if (firstBlend)
			{
				color = BiomeGradientTexture[int2(curveIndex, jitteredPoints[i].z)];
				firstBlend = false;
			}
			else
			{
				color = lerp(color, BiomeGradientTexture[int2(curveIndex, jitteredPoints[i].z)], distanceWeight);
			}
		}
	}
	//return float4((sumWeights / points) * 4, (sumWeights / points) * 4, (sumWeights / points) * 4, 0);
	return color;
}

float BlendHeights(float2 position, int curveIndex)
{
	float height = 0;
	bool firstBlend = true;
	float noise = CalculateBiomeBlendNoise(position);
	float radius = sqrt(2) / 2 + 1 / Resolution;
	for (int i = 0; i < jitteredPointsLength; i++)
	{
		float dx = abs(jitteredPoints[i].x - position.x);
		float dy = abs(jitteredPoints[i].y - position.y);
		float Distance = distance(position, float2(jitteredPoints[i].x, jitteredPoints[i].y));
		float centerWeight = distance(float2(0.5f, 0.5f), float2(jitteredPoints[i].x, jitteredPoints[i].y)) / radius;
		float biomeWeight = pow(max(0, pow(radius, 2) - pow(dx, 2) - pow(dy, 2)), 2);
		if (Distance <= BiomeBlendRadius)
		{
			float distanceWeight = (1 - (Distance / BiomeBlendRadius)) * noise + 0.05;
			if (firstBlend)
			{
				height = BiomeCurveTexture[int2(curveIndex, jitteredPoints[i].z)].r;
				firstBlend = false;
			}
			else
			{
				height = lerp(height, BiomeCurveTexture[int2(curveIndex, jitteredPoints[i].z)].r, distanceWeight);
			}
		}
	}
	return height;
}

[numthreads(8, 8, 1)]
void HeightMap(uint3 id : SV_DispatchThreadID)
{
	float x = id.x / Resolution;
	float y = id.y / Resolution;
	float noise = CalculateNoise(float2(x, y));
	//noise = pow(noise, 2.5);
	int curveIndex = (int) (noise * CurveResolution);
	if (BiomeHeights)
	{
		if (OutputBuffer[0].chunkBiome != -1)
			noise = BiomeCurveTexture[int2(curveIndex, OutputBuffer[0].chunkBiome)];
		else
			noise = BlendHeights(float2(x, y), curveIndex);
	}
	else
	{
		noise = HeightCurveTexture[int2(curveIndex, 0)];

	}
	HeightMapTexture[id.xy] = float4(noise, noise, noise, 0.0);
	curveIndex = (int) (noise * CurveResolution);
	if (DrawBiomes)
	{
		if (BiomeBlending)
		{
			//ColorMapTexture[id.xy] = float4(jitteredPoints[0].z, 0.0, 0.0, 0.0);
			if (OutputBuffer[0].chunkBiome != -1)
			{
				//ColorMapTexture[id.xy] = float4(0, 1, 0, 0.0);
				ColorMapTexture[id.xy] = BiomeGradientTexture[int2(curveIndex, OutputBuffer[0].chunkBiome)];
			}
			else
			{
				//ColorMapTexture[id.xy] = float4(OutputBuffer[0].chunkBiome + 1, 0.0, 0.0, 0.0);
				ColorMapTexture[id.xy] = BlendBiomes(float2(x, y), curveIndex);
			}
		}
		else
		{
			int biome = GetBiome(float2(x, y));
			ColorMapTexture[id.xy] = BiomeGradientTexture[int2(curveIndex, biome)];
		}
	}
	else
	{
		ColorMapTexture[id.xy] = BiomeGradientTexture[int2(curveIndex, 2)];
	}
}
