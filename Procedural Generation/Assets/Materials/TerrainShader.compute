// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel HeightMap
#pragma kernel BiomeMap
#pragma kernel BiomeBlendMap
#pragma kernel JitterPoints
#pragma kernel SetMapSettings
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise2D.hlsl"

RWTexture2D<float4> Result;

struct ChunkMap
{
	RWTexture2D<float4> MapTexture;
	float2 ChunkPosition;
};

struct Biome
{
	float temperature;
	float moisture;
};

struct Octave
{
	float frequency;
	float2 offset;
	float amplitude;
};

struct GPUMapSettings
{
	float Scale;
	float Size;
	float2 Offset;
	int OctaveCount;
	StructuredBuffer<Octave> Octaves;
	Texture2D<float4> Curve;
};




StructuredBuffer<float3> jitteredPoints;
StructuredBuffer<Biome> Biomes;
int BiomeLength;

RWTexture2D<float4> HeightMapTexture;
RWTexture2D<float4> ColorMapTexture;
Texture2D<float4> HeightCurveTexture;
Texture2D<float4> BiomeGradientTexture;

GPUMapSettings HeightMapSettings;
GPUMapSettings TemperatureMapSettings;
GPUMapSettings MoistureMapSettings;

float Resolution;
float CurveResolution;

int MapID;
float2 Offset;
float Scale;
float Size;
float2 ChunkPosition;
StructuredBuffer<Octave> Octaves;
int OctaveCount;

int GetBiome(float2 position)
{
	float temperature = 0;
	float moisture = 0;
	for (int i = 0; i < BiomeLength; i++)
	{
		if (temperature <= Biomes[i].temperature)
		{
			if (moisture <= Biomes[i].moisture)
			{
				return i;
			}
		}
	}
	return -1;
}
float CalculateNoise(int mapID, float2 position)
{
	GPUMapSettings settings;
	
	float mapSize = settings.Size;
	float2 chunkPosition = ChunkPosition;
	while (position.x < 0)
	{
		chunkPosition.x -= 1;
		position.x += Size;
	}
	while (position.x > Size)
	{
		chunkPosition.x += 1;
		position.x -= Size;
	}
	while (position.y < 0)
	{
		chunkPosition.y -= 1;
		position.y += Size;
	}
	while (position.y > Size)
	{
		chunkPosition.y += 1;
		position.y -= Size;
	}
	float2 offset = settings.Offset + chunkPosition - float2(2 * chunkPosition.x / Resolution, 2 * chunkPosition.y / Resolution);
	float height;
	float noiseHeight = 0;
	float sumAmplitudes = 0;
	for (int i = 0; i < settings.OctaveCount; i++)
	{
		float noiseX = (position.x + offset.x);
		float noiseY = (position.y + offset.y);
		noiseHeight += settings.Octaves[i].amplitude * ClassicNoise(float2(noiseX * settings.Octaves[i].frequency + settings.Octaves[i].offset.x, noiseY * settings.Octaves[i].frequency + settings.Octaves[i].offset.y)) / 2 + 0.0875f;
		sumAmplitudes += settings.Octaves[i].amplitude;
	}
	height = noiseHeight / sumAmplitudes;
	return height;
}

float CalculateNoise(float2 position)
{
	float mapSize = Size;
	float2 chunkPosition = ChunkPosition;
	while (position.x < 0)
	{
		chunkPosition.x -= 1;
		position.x += Size;
	}
	while (position.x > Size)
	{
		chunkPosition.x += 1;
		position.x -= Size;
	}
	while (position.y < 0)
	{
		chunkPosition.y -= 1;
		position.y += Size;
	}
	while (position.y > Size)
	{
		chunkPosition.y += 1;
		position.y -= Size;
	}
	float2 offset = Offset + chunkPosition - float2(2 * chunkPosition.x / Resolution, 2 * chunkPosition.y / Resolution);
	float height;
	float noiseHeight = 0;
	float sumAmplitudes = 0;
	for (int i = 0; i < OctaveCount; i++)
	{
		float noiseX = (position.x + offset.x);
		float noiseY = (position.y + offset.y);
		noiseHeight += Octaves[i].amplitude * ClassicNoise(float2(noiseX * Octaves[i].frequency + Octaves[i].offset.x, noiseY * Octaves[i].frequency + Octaves[i].offset.y)) / 2 + 0.0875f;
		sumAmplitudes += Octaves[i].amplitude;
	}
	height = noiseHeight / sumAmplitudes;
	return height;
}

[numthreads(1, 1, 1)]
void SetMapSettings(uint3 id : SV_DispatchThreadID) 
{
	if (MapID == 0) //Height Map
	{
		HeightMapSettings.Offset = Offset;
		HeightMapSettings.Scale = Scale;
		HeightMapSettings.Size = Size;
		HeightMapSettings.Octaves = Octaves;
		HeightMapSettings.OctaveCount = OctaveCount;
	} else if (MapID == 1) //Temperature Map
	{
		TemperatureMapSettings.Offset = Offset;
		TemperatureMapSettings.Scale = Scale;
		TemperatureMapSettings.Size = Size;
		TemperatureMapSettings.Octaves = Octaves;
		TemperatureMapSettings.OctaveCount = OctaveCount;
	} else if (MapID == 2) //Moisture Map
	{
		MoistureMapSettings.Offset = Offset;
		MoistureMapSettings.Scale = Scale;
		MoistureMapSettings.Size = Size;
		MoistureMapSettings.Octaves = Octaves;
		MoistureMapSettings.OctaveCount = OctaveCount;
	}
}

[numthreads(10, 1, 1)]
void JitterPoints(uint3 id : SV_DispatchThreadID)
{
	float3 oldPoint = jitteredPoints[id.x];
	float x = oldPoint.x / Resolution;
	float y = oldPoint.y / Resolution;
	float dir = oldPoint.z;
	
	float dist = 0.1f;
	
	float3 newPoint = float3(x + (cos(dir) * dist), y + (cos(dir) * dist), 0.0);

}

[numthreads(8, 8, 1)]
void BiomeMap(uint3 id : SV_DispatchThreadID)
{
	float height = HeightMapTexture[id.xy];
	float x = id.x / Resolution;
	float y = id.y / Resolution;
	
	int biome = GetBiome(float2(x, y));
	if (biome != -1)
	{
		int gradientIndex = (int) (HeightMapTexture[id.xy] * 100);
		ColorMapTexture[id.xy] = BiomeGradientTexture[int2(gradientIndex, biome)];
	}

}

[numthreads(8, 8, 1)]
void BiomeBlendMap(uint3 id : SV_DispatchThreadID)
{
	
}

[numthreads(8, 8, 1)]
void HeightMap(uint3 id : SV_DispatchThreadID)
{
	float x = id.x / Resolution;
	float y = id.y / Resolution;
	float noise = CalculateNoise(float2(x, y));
	noise = pow(noise, 2.5);
	int curveIndex = (int) (noise * CurveResolution);
	//noise = HeightCurveTexture[int2(curveIndex, 0)];
	HeightMapTexture[id.xy] = float4(noise, noise, noise, 0.0);
	//curveIndex = (int)(noise * CurveResolution);
	ColorMapTexture[id.xy] = BiomeGradientTexture[int2(curveIndex, 1)];
	//Result[id.xy] = float4(curveIndex / 99.5, 0, 0, 0);

}

